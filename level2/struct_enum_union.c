#include<stdio.h> 
//结构体内存对齐
    // 1. 第一个成员在与结构体变量偏移量为0的地址处。
    // 2. 其他成员变量要对齐到某个数字（对齐数）的整数倍的地址处。
    // 对齐数 = 编译器默认的一个对齐数 与 该成员大小的较小值。
    // VS中默认的值为8
    // 3. 结构体总大小为最大对齐数（每个成员变量都有一个对齐数）的整数倍。
    // 4. 如果嵌套了结构体的情况，嵌套的结构体对齐到自己的最大对齐数的整数倍处，结构体的整
    // 体大小就是所有最大对齐数（含嵌套结构体的对齐数）的整数倍。
//为什么要内存对齐
    // 大部分的参考资料都是如是说的：
    // 1. 平台原因(移植原因)：
    // 不是所有的硬件平台都能访问任意地址上的任意数据的；某些硬件平台只能在某些地址处取某些特
    // // 定类型的数据，否则抛出硬件异常。
// #pragma pack(8)
// struct S
// {
//     int i;//4
//     int j;//4
//     char c;//1
// } ;
// struct S2
// {
//     double d;
//    char c;
//   int k;
// };

// int main()
// {
   
// int ret = sizeof(struct S2);
// printf("%d",ret);

// }
//结构体内存对齐过程
//定义结构体后，在内存中开辟一连串空间，
//已知，vscode的默认对齐数是8
//先从0处开始存i，占4个字节，直到偏移量为3的空间，（0，1，2，3）
//再存j占四个字节，直到偏移量为7的空间（4，5，6，7）
//最后存char c，占一个字节。直接存到8的空间（8）
//全体大小加起来为9，而整个结构体成员中最大对齐数为4，则结构体占的总内存空间为
//12个字节应为4的整数倍，所以从0-9存放后，再偏移三个空字节到偏移量为12(最大内存对齐数的整数倍)的位置为止。
//总浪费了三个字节

// int -32  4x8bit
// char 8   1x8bit
//字节—>bit
///位段
    //成员均为整形家族成员
    //冒号后的数字，表示该变量，所分配的比特位，如a假如是一般整形则占4个字节，而使用我位段设置，只用占2个比特位
    //其可以用来节省内存空间
#pragma pack(9)
struct A
{
    int _b:2;
    int _a:5;
    char _c:3;
};
#pragma pack(pop)

int main()
{
    struct A wei;

    int ret = sizeof((wei));
    printf("%d",ret);
}
